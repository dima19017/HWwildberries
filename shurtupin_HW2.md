4. Сделать в первой сессии новую таблицу и наполнить ее данными  
psql -d wb  
wb=# create table test (tint int unique, ttext text);  
wb=# INSERT INTO test (tint, ttext) VALUES (1, 'firstrow'),(2, 'secondrow'),(3, 'thirdrow'),(4, 'fourthrow');  
5. Посмотреть текущий уровень изоляции  
wb=# show default_transaction_isolation;  
 read committed  
6. Начать новую транзакцию в обеих сессиях с дефолтным (не меняя) уровнем изоляции  
1: wb=# begin;  
2: wb=# begin;  
7. В первой сессии добавить новую запись  
1: wb=*# insert into test values (5, 'fifthrow');  
8. Сделать запрос на выбор всех записей во второй сессии  
2: wb=*# select * from test ;  
 tint |   ttext  
------+-----------  
    1 | firstrow  
    2 | secondrow  
    3 | thirdrow  
    4 | fourthrow  
9. Видите ли вы новую запись и если да то почему?  
Новая запись не видна, потому что в postgres ни один уровень изоляции не позволяет видеть незафиксированные данные  
10. Завершите транзакцию в пером окне  
1: wb=*# commit;  
11. Сделать запрос на выбор всех записей во второй сессии  
2: wb=*# select * from test ;  
12. Видите ли вы новую запись и если да то почему?  
Запись видна, так как изменения были зафиксированы  
13. Завершите транзакцию во второй сессии  
2: wb=*# commit;  
14. Начать новые записи, но уже на уровне repeatable read в обеих сессиях  
1: wb=# START TRANSACTION ISOLATION LEVEL REPEATABLE READ;  
2: wb=# START TRANSACTION ISOLATION LEVEL REPEATABLE READ;  
Дальше все те же действия  
До фиксации: Новая запись не видна, потому что в postgres ни один уровень изоляции не позволяет видеть незафиксированные данные    
После фиксации: новая запись не видна, потому что уровень изоляции repeatable read гарантирует, что если транзакция прочитала данные, то при их повторном прочтении они останутся теми же (non-repeatable read)  
P.S.: При этом если не сделать выборку по нашей таблице, а лишь начать транзакцию, то при фиксации изменений в первом сеансе мы увидим их во втором.  